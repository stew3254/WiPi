#!/bin/bash

#Used to print verbose statements
verbose() {
  if [ $verbosity = true ]; then
    for i in "$@"; do
      echo $i
    done
  fi
}

#Show help
showHelp() {
  echo "Usage: $(basename $0) [stop|start|restart] [OPTIONS] <interface>" >&2
  echo "Used to create wireless access points with ease"
  echo
  echo "OPTIONS:"
  echo -e "  -c  --channel  <channel>\tChannel the access point is broadcasted on"
  echo -e "  -e  --essid  <ESSID>\t\tESSID of the access point"
  echo -e "  -d  --domain  <domain>\tDomain name of the local network created by dnsmasq"
  echo -e "  -h  --help\t\t\tShows this menu"
  echo -e "  -i  --interface  <interface>\tThe interface used to route traffic out of (default is eth0)"
  echo -e "  -v  --verbose\t\t\tIncreases verbosity output of the program"
  echo
  echo "Examples:"
  echo "  $(basename $0) start -c 1 -d foo.net --essid Foo wlan0"
  echo "  $(basename $0) restart -e 'Free WiFi' -c11 -i enp2s0 wlp3s0"
  echo "  $(basename $0) stop wlan1"
}

#Check to see if the interface exists. If not, exit
checkInterface() {
  if [ -z "$interface" ]; then
    echo "No interface specified. Please specify a wireless interface"
    exit 1;
  elif [ -z "`ip l | grep $interface`" ]; then
    echo "Interface $interface does not exist. Please choose an interface that exists"
    exit 1;
  elif [ -z "`iw dev | grep $interface`" ]; then
    echo "Interface $interface isn't a wireless card. Please choose an interface that is"
    exit 1;
  elif [ -z "`iw list | grep monitor`" ]; then
    echo "Interface $interface doesn't support monitor mode. Unfortunately this script won't work without that"
    exit 1;
  fi
}

#Create new hostapd config file
hostapdConfigure() {
  #Create the config file
  wap="interface=$interface\ndriver=nl80211\nssid=$name\nhw_mode=g\nchannel=$channel\nwmm_enabled=0\nmacaddr_acl=0\nauth_algs=1\nignore_broadcast_ssid=0"

  echo -e $wap> /etc/hostapd/hostapd.conf

  #Make sure our config file gets loaded
  sed -ie 's/DAEMON_CONF="/DAEMON_CONF="\/etc\/hostapd\/hostapd.conf/g' /etc/default/hostapd
  sed -ie 's/#DAEMON_CONF/DAEMON_CONF/g' /etc/default/hostapd
}

#Set up hostapd and dnsmasq
setup() {
  #dnsmasq and hostapd configs
  dnsmasqConfig=false
  hostapdConfig=false

  #Check if the dnsmasq.conf file exists
  checkConfig="`ls /etc | grep dnsmasq.conf`"
  for i in $checkConfig; do
    #Check to see if that exact config file exists
    if [ "$i" = "dnsmasq.conf" ]; then
      dnsmasqConfig=true
      break
    fi
  done

  #If config exists, leave it. Otherwise create a new one
  if [ $dnsmasqConfig = true ]; then
    verbose "dnsmasq config file found. Leaving existing config."
  else
    echo "domain-needed" > /etc/dnsmasq.conf #Blocks incomplete requests from leaving the network
    echo "bogus-priv" >> /etc/dnsmasq.conf #Prevents private addresses from being forwarded
    echo "no-resolv" >> /etc/dnsmasq.conf #Don't read /etc/resolv.conf for DNS servers
    echo "domain=$domain" >> /etc/dnsmasq.conf #Set the local domain
    echo "expand-hosts" >> /etc/dnsmasq.conf #Allow hosts to use this domain
    echo "local=/$domain/ " >> /etc/dnsmasq.conf #Ensures the domain is private
    echo "listen-address=127.0.0.1" >> /etc/dnsmasq.conf #Make sure dnsmasq listens on the right networks
    echo "listen-address=192.168.4.1" >> /etc/dnsmasq.conf #Make sure dnsmasq listens on the right networks
    echo ""  >> /etc/dnsmasq.conf
    echo "interface=$interface" >> /etc/dnsmasq.conf #Set the interface to route on 
    echo "  dhcp-range=192.168.4.2,192.168.4.254,255.255.255.0,5m" >> /etc/dnsmasq.conf #Set the ip range
    echo "  dhcp-option=3,192.168.4.1" >> /etc/dnsmasq.conf #Set the router IP
    echo "  dhcp-option=6,192.168.4.1" >> /etc/dnsmasq.conf #Set the DHCP server IP
    echo "  server=8.8.8.8" >> /etc/dnsmasq.conf #Set upstream DNS server to Google
    echo "  server=8.8.4.4" >> /etc/dnsmasq.conf #Set upstream DNS server to Google
    echo ""  >> /etc/dnsmasq.conf
    echo "bind-interfaces" >> /etc/dnsmasq.conf #Makes sure dnsmasq only listens on specified interfaces
    echo "log-facility=/var/log/dnsmasq.log" >> /etc/dnsmasq.conf #Set the logs file
    echo "log-queries" >> /etc/dnsmasq.conf #Logs queries
    echo "log-dhcp" >> /etc/dnsmasq.conf #Logs dhcp

    echo "192.168.4.1 $domain" > /etc/dnsmasq.hosts #Creates a dns entry to allow the domain to be pinged
    verbose "dnsmasq config file not found. Created a new one"
  fi

  #Check to see if a hostapd config file exists
  checkConfig="`ls /etc/hostapd | grep hostapd.conf`"
  for i in $checkConfig; do
    #Check to see if that exact config file exists
    if [ "$i" = "hostapd.conf" ]; then
      hostapdConfig=true
      break
    fi
  done

  #If config exists, leave it. Otherwise create a new one
  if [ $hostapdConfig = true ]; then
    verbose "hostapd config file found. Creating a backup of the old one."
    mv /etc/hostapd/hostapd.conf /etc/hostapd/hostapd.conf.old
    verbose "Backup file located at /etc/hostapd/hostapd.conf.old"
    hostapdConfigure
  else
    hostapdConfigure
    verbose "hostapd config file not found. Created a new one"
  fi
}

#Check to make sure the dependencies are installed
checkDepends() {
  depend="wireless-tools iptables hostapd dnsmasq"

  #Check for each dependency
  for item in $depend; do
    #Check in the installed programs lists
    programList="`dpkg -l | grep $item | sed -e 's/  */ /g' | cut -d ' ' -f 2`"
    realProgram=""

    #Go through each program found in the list and make sure it's actually correct
    for program in $programList; do
      #Check to make sure the program has the exact same name
      if [ $program = $item ]; then
        realProgram="$item"
      fi
    done

    if [ -z $realProgram ]; then
      #Read input
      read -p "$item not installed. Would you like to install it now? (y/n) " input

      #Check to make sure the user agrees
      #If so install it. It not, exit the program. Otherwise, wait for a valid option
      while true; do
        if [ "$input" = "y" ] || [ "$input" = "Y" ]; then
          apt install $item -y
          systemctl stop $item
          break
        elif [ "$input" = "n" ] || [ "$input" = "N" ]; then
          echo "Exiting"
          exit 0
        else
          read -p "Please enter a valid option. (y/n) " input
        fi
      done
    fi
  done

  setup
}

startAP() {
  #Check to see if the interface exists
  checkInterface

  #Check to make sure the dependencies are installed
  checkDepends

  #Set up iptables rules
  verbose "Saving existing iptables rules to /etc/iptables.ipv4.nat"
  sh -c "iptables-save" > /etc/iptables.ipv4.nat

  verbose "Creating new routing rules"
  iptables -F
  iptables -t nat -A  POSTROUTING -o $ipInterface -j MASQUERADE
  iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
  #iptables -i $interface -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  #iptables -i $interface -A INPUT -p tcp --dport 443 -j ACCEPT
  #iptables -i $interface -A INPUT -p tcp --dport 80 -j ACCEPT
  #iptables -i $interface -A INPUT -p udp --dport 67:68 -j ACCEPT
  #iptables -i $interface -A INPUT -p udp --dport 53 -j ACCEPT
  #iptables -i $interface -A INPUT -p tcp --dport 53 -j ACCEPT
  #iptables -i $interface -A INPUT -p tcp --dport 22 -j ACCEPT
  #iptables -i $interface -A INPUT -j DROP

  #Enable ip forwarding
  if [ "`cat /proc/sys/net/ipv4/ip_forward`" -eq 0 ]; then
    verbose "Enabling ip forwarding"
    echo 1 > /proc/sys/net/ipv4/ip_forward
  fi

  #Killing conflicting processes
  verbose "Killing Network Manager"
  pkill NetworkManager
  verbose "Killing wpa supplicant"
  pkill wpa_supplicant

  #Configure hostapd
  hostapdConfigure

  #Set the access point into monitor mode
  verbose "Putting the interface into monitor mode"
  ip l set $interface down
  iwconfig $interface mode monitor
  ip l set $interface up

  #Start the access point
  if [ "$mode" = "start" ]; then
    echo "Starting access point $name"
  fi
  hostapd -d /etc/hostapd/hostapd.conf &> /dev/null &

  #Add an ip address
  verbose "Adding static ip 192.168.4.1 to interface $interface"
  ip a add 192.168.4.1/24 dev $interface
  #echo "Adding static route to 192.168.4.1"
  #ip r add default via 192.168.4.1 dev at0

  #Start the dhcp and dns server
  verbose "Starting dnsmasq"
  sleep .5
  systemctl restart dnsmasq
}

stopAP() {
  #Check to see if the interface exists
  checkInterface

  #Kill dnsmasq
  verbose "Stopping dnsmasq"
  systemctl stop dnsmasq

  #Kill the access point
  verbose "Stopping hostapd"
  pkill hostapd

  verbose "Putting the interface back into managed mode"
  #Put the interface back into managed mode
  ip a del 192.168.4.1/24 dev $interface
  ip l set $interface down
  iwconfig $interface mode managed
  ip l set $interface up

  #Restore iptables rules
  verbose "Restoring old iptables rules"
  iptables-restore < /etc/iptables.ipv4.nat

  if [ "$mode" = "stop" ]; then
    echo "Access point stopped"
  fi
}

#Make sure user is root
if [ $EUID -ne 0 ]; then
  echo "You must be root in order to run this program"
  exit 1
fi

#Set default parameters
mode="$1"
verbosity=false
interface=""
ipInterface="eth0"
name="Test"
channel=1
domain="mydomain.net"

#Read the options and set them
OPTIONS=`getopt -o hvc:e:d:i: --long help,verbose,channel:,essid:,domain,interface -n $(basename $0) -- "$@"`
eval set -- "$OPTIONS"

#Extract options and their arguments into variables.
while true ; do
    case "$1" in
        -h|--help) showHelp; exit 0 ;; #Show help
        -v|--verbose) verbosity=true; shift ;; #Set verbosity flag to true
        -c|--channel) shift; channel=$1; shift ;; #Set the channel
        -e|--essid) shift; name=$1; shift ;; #Set the name
        -d|--domain) shift; domain=$1; shift ;; #Set the domain
        -i|--interface) shift; ipInterface=$1; shift ;; #Set the domain
        --) shift ; break ;; #Break to parse non opts
        *) echo "Internal error!";  exit 1 ;; #SHTF! EXIT NOW!
    esac
done
interface="$2"

#Check to see if the access point should be restarted
if [ "$mode" = "restart" ];then
  stopAP
  startAP
  echo "Restarted the access point."
  echo "New name is $name"
#Check to see if the access point should be started
elif [ "$mode" = "start" ]; then
  startAP
#Check to see if the access point should be stopped
elif [ "$mode" = "stop" ]; then
  stopAP
#Message for help if the command is used wrong
else
  showHelp
fi
